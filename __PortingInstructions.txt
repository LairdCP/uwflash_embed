*******************************************************************************
December 2016  :: Source Code for implementing a firmware downloader in your
                  host microcontroller system.
*******************************************************************************

Many Laird Modules are capable of firmware being downloaded over the uart 
interface of the module and is expedited with the help of a bootloader
embedded in the module.

New firmware is provided by Laird as and when there are new features or bug
fixes and are delivered in a file with an extension ".uwf" which has content
formatted in a custom Laird specific way which is neither pure binary nor
in hex.

The custom format is to ensure that partial loads of firmware do not result in
the bootloader being confused so that it launches into the new firmware.

Laird offers a Windows utility that enables the content of the ".uwf" file 
to be downloaded to that module.

Many customers have requested that they be able to download the new firmware
from a host microcontroller which is physically connected to the uart pins
of the module and so connecting a Windows PC becomes problematic.

In some cases this has been solved by the customer writing bridging code between
an external facing uart and the uart that is connected to the module.

Laird now offers C++ source code which the customer can embed into their
host microcontroller which acts like a black-box so that assuming that the
host micro has access to the .uwf file content somehow (like in a serial flash
or an sdio card, or over say another link like wifi or ethernet) it is as simple
as calling a single blocking function called  UwFlashUpgradeFirmare();
                    ^^^^^^^^
                    
The blocking blackbox engine does not spawn any threads and will block for
around 50 to 120 seconds. 
To be cooperative with your normal functionality it will poll a function called
MiscPollBackgroundTarget() where you can put your code that can be polled
OR you could launch the function UwFlashUpgradeFirmare() in a thread if 
you have an RTOS.

If the decision is made to run the engine in a seperate thread then it
is up to the developer to ensure multi-thread access to serial buffers
are appropriately syncronised.
                    
Laird obviously cannot predict the actual uart interface that will exist
in a customer host microcontroller and so it is left to the customer to 
provide code in functions that are called from within the black-box which
enables interaction with the uart. In addition, the customer needs to provide
code for file open/read/close functions that are called to get the content
of the .uwf file and similarly as the firmware upgrade progresses there 
are functions that are called to convey the progress. The upgrade progress
function calls can remain as stubs if you prefer. Although you may find 
that monitoring the state value will convey what it is up to.

There are 5 files in the subfolder 'HostTemplate' that need to be coded, and
please view them in any text editor and search for the text "TODO". 
We recommend that you copy that folder and modify those new files.
You will find copious comments that will convey the functionality you need 
to code.
As an example, see subfolder 'WindowsExample' where the blackbox has been
used to prove the upgrade process in a Windows PC.

With regards to TSerialPortTarget.cpp which implements your custom code
for accessing the uart that is connected to the module, one strategy
which has been proven to work is for there to be a low level receive 
buffer into which a thread or an interrupt routine stores the incoming
data and then leave it to the engine to read from it's thread (or background).
You do not have to worry about how that will get done.

Basically, the function SerialRxDataCount() will be polled by the engine
and when you provide a count that is non-zero, then the function
TSerialPortTarget::GetBlock() will eventually get called to read the data
that has newly arrived. Ensure that when the data is read there are no
multithreading issues. Once the data is read by TSerialPortTarget::GetBlock()
it is assumed that it will be removed from the underlying low level buffer.

Please note that above, it has been commented that the firmware upgrade
time can take from 50 to 120 seconds for the same file and same module.
This timing is dependent on the value of #define UWF_FIRMWAREFILE_MAX_LINE_LEN
which is set by default to 1024. If that value is reduced to say 256 then
the engine will work with smaller chunks of information from the .uwf file
and that has the impact of increasing the time. 
Obviusly only you are able to judge how much memory you have spare which
is taken from the heap.

If you do decide to alter the value of UWF_FIRMWAREFILE_MAX_LINE_LEN or any
other #define in the file WirelessModule\TargetEmbed.h, please do NOT alter
that file but in the Target.h do as follows:-

#undef UWF_FIRMWAREFILE_MAX_LINE_LEN
#define UWF_FIRMWAREFILE_MAX_LINE_LEN  (some_new_value)

********************************
Files to include in your project
********************************

  (*) All .cpp and .c files in folder 'SourceLibrary'
  (*) TargetEmbed.h & one of TBootLdr?????.cpp from folder 'WirelessModule'
  (*) Copy all files from folder 'HostTemplate' into a folder of your choice
      and then update them. Look for the text "TODO" in all these files
      as that is where you will need to add your code that provides uart
      and file read access.

*****************
Testing
*****************
The code has been tested in the harness in the folder "WindowsExample" where
Borland Builder v6 has been used along with a serial port VCL component
called Asyncpro.
Both TARGET_BL65X and TARGET_BL6XX has been tested.













                    
     




